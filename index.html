
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>They Lied — Meme Maker (v4.4)</title>
<style>
  :root{ --bg:#0f0f10; --panel:#16171a; --ink:#e9e9ea; --brand:#ca3028; }
  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{ margin:0; background:var(--bg); color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial; }
  .app{ display:grid; grid-template-rows:auto 1fr; height:100% }

  /* Top bar */
  .top{ display:flex; gap:10px; align-items:center; padding:10px 14px; background:#111214; border-bottom:1px solid #23252a; position:relative }
  .btn, select, input[type=color], input[type=range]{ background:#23252a; color:var(--ink); border:1px solid #2f3238; border-radius:10px; height:36px; padding:0 10px; cursor:pointer }
  .btn{ display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; height:36px }
  .sp{ flex:1 }
  .zoom{ display:flex; align-items:center; gap:8px; position:absolute; right:14px; top:10px }
  #zoomPct{ width:70px; text-align:right; }

  /* Layout */
  .work{ display:grid; grid-template-columns: 320px 1fr; min-height:0 }
  .side{ background:var(--panel); border-right:1px solid #23252a; padding:12px; overflow:auto }
  .side h3{ margin:8px 0; font-size:14px; opacity:.9 }
  .group{ display:grid; gap:8px; margin:10px 0 16px }
  .muted{ opacity:.7; font-size:12px }

  /* Stage viewport */
  #stageViewport{ position:relative; overflow:auto; padding:32px; display:grid; place-items:center; }
  #stageScroller{ width:max-content; height:max-content; }
  #stage{ position:relative; width:1600px; height:900px; background:#f7f7f8; box-shadow:0 20px 60px rgba(0,0,0,.5); overflow:hidden; }
  .el{ position:absolute; user-select:none; cursor:move; will-change:transform,left,top,width,height; contain: layout paint size; }
  .el.selected{ outline:2px solid #4da3ff }
  .el img{ display:block; width:100%; height:100%; object-fit:contain; pointer-events:none; }
  .handle{ position:absolute; right:-8px; bottom:-8px; width:14px; height:14px; background:#4da3ff; border-radius:3px; cursor:nwse-resize }
  .stamp{ display:inline-block; background:var(--brand); color:#fff; font-weight:900; padding:.18em .5em; letter-spacing:.5px }

  #drawCanvas{ position:absolute; inset:0; pointer-events:none; z-index:1000; }

  .bubble{ position:fixed; bottom:16px; right:16px; background:#141518; border:1px solid #2b2e34; border-radius:12px; padding:10px; display:flex; gap:8px; align-items:center }
  .bubble input[type=text]{ width:320px; background:#1e2025; border:1px solid #2b2e34; border-radius:10px; color:var(--ink); height:36px; padding:0 10px }

  .version{ position:fixed; left:12px; bottom:10px; font-size:12px; opacity:.6; pointer-events:none; }

  /* Marquee selection */
  #marquee{ position:fixed; border:1px dashed #4da3ff; background:rgba(77,163,255,.15); display:none; z-index:99999; pointer-events:none; }
  /* Group box */
  #groupBox{ position:absolute; border:2px solid #4da3ff; pointer-events:none; display:none; }
  #groupHandle{ position:absolute; right:-7px; bottom:-7px; width:14px; height:14px; background:#4da3ff; border-radius:3px; cursor:nwse-resize; pointer-events:auto; }
</style>
</head>
<body>
<div class="app">
  <div class="top">
    <button class="btn" id="blank">Blank</button>
    <select id="tpl">
      <option value="none">Choose Template…</option>
      <option value="beforeAfter">Before / After</option>
      <option value="reaction">Hoodie Reaction</option>
      <option value="lieWeek">Lie of the Week</option>
      <option value="collage">Receipts Collage (2×2)</option>
      <option value="chart">Chart Dunk</option>
      <option value="villains">Villain Board (Top 6)</option>
      <option value="stampOnly">Stamp Only</option>
    </select>
    <button class="btn" id="undo">Undo</button>
    <button class="btn" id="redo">Redo</button>
    <div class="sp"></div>
    <div class="zoom">
      <button class="btn" id="fit">Fit</button>
      <input type="range" id="zoom" min="50" max="200" value="50">
      <div id="zoomPct">50%</div>
      <button class="btn" id="export">Export PNG</button>
    </div>
  </div>

  <div class="work">
    <div class="side">
      <h3>Add</h3>
      <div class="group">
        <button class="btn" id="addText">Text</button>
        <button class="btn" id="addLogo">Logo</button>
        <button class="btn" id="addStamp">THEY LIED Stamp</button>
        <button class="btn" id="addMascot">Lerpy Liar</button>
        <input id="uploader" type="file" accept="image/*" multiple />
        <div class="muted">Shift‑click to multi‑select. Drag on empty space to marquee‑select. Drag to move. Drag blue square to resize. Double‑click text to edit.</div>
      </div>

      <h3>Arrange</h3>
      <div class="group">
        <button class="btn" id="front">Bring Front (to top)</button>
        <button class="btn" id="back">Send Back (to bottom)</button>
        <button class="btn" id="dup">Duplicate</button>
        <button class="btn" id="del">Delete</button>
        <button class="btn" id="clear">Clear All</button>
      </div>

      <h3>Canvas</h3>
      <div class="group">
        <div>
          <select id="sizeSel">
            <option value="1600x900">Wide 1600×900</option>
            <option value="1920x1080">HD 1920×1080</option>
            <option value="2048x1152">YouTube 2048×1152</option>
            <option value="1080x1080">Square 1080×1080</option>
          </select>
          <button class="btn" id="applySize">Apply</button>
        </div>
        <div style="display:flex;align-items:center;gap:8px;margin-top:8px;">
          <span class="muted">BG</span> <input type="color" id="bg" value="#f7f7f8" />
        </div>
      </div>

      <h3>Draw (Paint)</h3>
      <div class="group">
        <div style="display:flex;align-items:center;gap:8px;">
          <button class="btn" id="drawToggle">Enable Draw</button>
          <input type="color" id="brushColor" value="#000000" title="Brush color" />
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="muted">Size</span>
          <input type="range" id="brushSize" min="2" max="80" value="14" />
          <button class="btn" id="clearDraw">Clear</button>
        </div>
        <div class="muted">Each stroke becomes a movable layer when you release the mouse.</div>
      </div>
    </div>

    <div id="stageViewport">
      <div id="stageScroller">
        <div id="stage">
          <canvas id="drawCanvas"></canvas>
          <div id="groupBox"><div id="groupHandle"></div></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="version" id="versionLabel"></div>
<div id="marquee"></div>

<div class="bubble" id="editor">
  <input type="text" id="txt" placeholder="Type text… (double‑click a text box first)" />
  <select id="fontFamily" title="Font">
    <option value="Impact, Arial Black, Inter, Arial, sans-serif">Impact</option>
    <option value="Anton, Impact, Arial Black, Inter, Arial, sans-serif">Anton</option>
    <option value="Arial Black, Impact, Inter, Arial, sans-serif">Arial Black</option>
    <option value="Inter, Arial, sans-serif">Inter</option>
    <option value="Arial, sans-serif">Arial</option>
  </select>
  <input type="number" id="fs" min="12" max="400" value="64" title="Font size" />
  <input type="color" id="fc" value="#000000" title="Color" />
  <button class="btn" id="stampStyle">Stamp Style</button>
</div>

<script>
(function(){
  const VERSION = "4.4"; // change once per release; label updates automatically
  document.getElementById('versionLabel').textContent = "They Lied Meme Generator " + VERSION;

  const ASSETS = {
    logo: "https://static.wixstatic.com/media/d7bc5f_9f109787e65c463d82461169f65dda33~mv2.png/v1/fill/w_784,h_784,al_c,q_90,usm_0.66_1.00_0.01,enc_avif,quality_auto/logo_2x.png",
    stampImg: "https://static.wixstatic.com/media/d7bc5f_e5d4a1012e8e4c46a206fb9bb975feef~mv2.png/v1/fill/w_1158,h_246,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/Middel%205_2x.png",
    mascot: "https://static.wixstatic.com/media/d7bc5f_a32ee7723b124d368056b6d6aa0a860b~mv2.png/v1/fill/w_630,h_630,al_c,q_90,usm_0.66_1.00_0.01,enc_avif,quality_auto/They%20Lied%20MAscot%201.png"
  };

  const stage = document.getElementById('stage');
  const scroller = document.getElementById('stageScroller');
  const viewport = document.getElementById('stageViewport');
  const drawCanvas = document.getElementById('drawCanvas');
  const dctx = drawCanvas.getContext('2d');
  dctx.imageSmoothingEnabled = true;
  dctx.imageSmoothingQuality = 'high';
  let z=10, uploadCount=0, scale=1;

  // Selection (multi)
  let selection = new Set();
  const groupBox = document.getElementById('groupBox');
  const groupHandle = document.getElementById('groupHandle');
  const marquee = document.getElementById('marquee');

  function clearSelection(){ selection.forEach(el=>el.classList.remove('selected')); selection.clear(); updateGroupBox(); }
  function addToSelection(el){ if(!selection.has(el)){ selection.add(el); el.classList.add('selected'); } updateGroupBox(); }
  function setSingleSelection(el){ clearSelection(); if(el){ selection.add(el); el.classList.add('selected'); } updateGroupBox(); }
  function isSelected(el){ return selection.has(el); }

  function updateGroupBox(){
    if(selection.size<=1){ groupBox.style.display='none'; return; }
    let minL=Infinity,minT=Infinity,maxR=-Infinity,maxB=-Infinity;
    selection.forEach(el=>{
      const l=parseFloat(el.style.left)||0, t=parseFloat(el.style.top)||0, w=el.clientWidth, h=el.clientHeight;
      minL=Math.min(minL,l); minT=Math.min(minT,t); maxR=Math.max(maxR,l+w); maxB=Math.max(maxB,t+h);
    });
    groupBox.style.display='block';
    groupBox.style.left = minL+'px'; groupBox.style.top=minT+'px';
    groupBox.style.width = (maxR-minL)+'px'; groupBox.style.height=(maxB-minT)+'px';
  }

  // History
  const history = []; let hIndex=-1; const MAX_HIST=50;
  function snapshot(){
    const els=[...stage.querySelectorAll('.el')].map(el=>{
      const box = el.firstChild;
      return {
        t: el.dataset.type,
        x: parseFloat(el.style.left)||0,
        y: parseFloat(el.style.top)||0,
        w: el.clientWidth,
        h: el.dataset.type==='text'? null : el.clientHeight,
        z: parseInt(getComputedStyle(el).zIndex)||1,
        src: (el.dataset.type!=='text')? (box.src||'') : null,
        txt: el.dataset.type==='text' ? box.textContent : null,
        font: el.dataset.type==='text' ? getComputedStyle(box).fontFamily : null,
        size: el.dataset.type==='text' ? parseInt(getComputedStyle(box).fontSize) : null,
        color: el.dataset.type==='text' ? getComputedStyle(box).color : null,
        stamp: el.dataset.type==='text' ? box.classList.contains('stamp') : null
      };
    });
    const drawData = drawCanvas.toDataURL();
    const state = { bg: getComputedStyle(stage).backgroundColor, size:[drawCanvas.width, drawCanvas.height], els, drawData };
    history.splice(hIndex+1);
    history.push(state);
    if(history.length>MAX_HIST){ history.shift(); }
    hIndex = history.length-1;
  }
  function restore(state){
    [...stage.querySelectorAll('.el')].forEach(n=>n.remove());
    uploadCount=0; selection.clear();
    setSize(state.size[0], state.size[1]);
    stage.style.background = state.bg;
    const img=new Image(); img.onload=()=>{ dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); dctx.drawImage(img,0,0); };
    img.src = state.drawData;
    for(const it of state.els){
      if(it.t==='text'){
        const el = mkEl('text',{x:it.x,y:it.y,w:it.w,text:it.txt,size:it.size,font:it.font,color:it.stamp? '#fff' : it.color});
        if(it.stamp) el.firstChild.classList.add('stamp');
        el.style.zIndex = it.z;
      }else{
        const el = mkEl(it.t==='img'?'img':'asset',{x:it.x,y:it.y,w:it.w,h:it.h,src:it.src});
        el.style.zIndex = it.z;
      }
    }
    clearSelection();
  }
  function undo(){ if(hIndex>0){ hIndex--; restore(history[hIndex]); } }
  function redo(){ if(hIndex<history.length-1){ hIndex++; restore(history[hIndex]); } }
  document.getElementById('undo').onclick = ()=>{ undo(); };
  document.getElementById('redo').onclick = ()=>{ redo(); };
  document.addEventListener('keydown', (e)=>{
    const mod = e.ctrlKey || e.metaKey;
    if(mod && !e.shiftKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
    if(mod && e.shiftKey && e.key.toLowerCase()==='z'){ e.preventDefault(); redo(); }
  });

  // Size / BG
  function setSize(w,h){
    stage.style.width=w+'px'; stage.style.height=h+'px';
    drawCanvas.width = w; drawCanvas.height = h;
  }
  setSize(1600,900);
  stage.style.background = '#f7f7f8';

  // Zoom
  function applyZoom(newScale){
    scale = Math.max(0.5, Math.min(2, newScale));
    scroller.style.transform = `scale(${scale})`;
    scroller.style.transformOrigin = 'top left';
    document.getElementById('zoom').value = Math.round(scale*100);
    document.getElementById('zoomPct').textContent = Math.round(scale*100) + '%';
  }
  document.getElementById('zoom').addEventListener('input', (e)=> applyZoom(e.target.value/100));
  document.getElementById('fit').addEventListener('click', ()=>{
    const vw = viewport.clientWidth - 32;
    const vh = viewport.clientHeight - 32;
    const w = stage.clientWidth, h = stage.clientHeight;
    const s = Math.max(0.5, Math.min(2, Math.min(vw/w, vh/h)));
    applyZoom(s);
  });
  applyZoom(0.5);

  // Helpers
  function mkEl(type, opts={}){
    const el = document.createElement('div');
    el.className='el'; el.dataset.type=type;
    el.style.left=(opts.x||40)+'px'; el.style.top=(opts.y||40)+'px';
    el.style.width=(opts.w||300)+'px';
    el.style.height=(type==='text'?'auto': (opts.h||300)+'px');
    el.style.zIndex=++z;

    if(type==='img' || type==='asset'){
      const img=new Image();
      img.crossOrigin='anonymous';
      img.src = opts.src;
      img.style.width='100%'; img.style.height='100%'; img.style.display='block'; img.style.pointerEvents='none';
      el.appendChild(img);
    } else if(type==='text'){
      const box=document.createElement('div');
      box.textContent = opts.text || 'YOUR TEXT';
      box.style.fontWeight='900';
      box.style.fontFamily=opts.font||'Impact, Arial Black, Inter, Arial, sans-serif';
      box.style.fontSize=(opts.size||64)+'px';
      box.style.color=opts.color||'#000';
      box.style.lineHeight='1.05';
      box.style.display='inline-block';
      el.appendChild(box);
    }
    const handle=document.createElement('div'); handle.className='handle'; el.appendChild(handle);

    el.addEventListener('pointerdown', (e)=> onElementPointerDown(e, el));
    handle.addEventListener('pointerdown', (e)=> startResize(e, el, handle));
    el.addEventListener('dblclick', ()=>{ if(el.dataset.type==='text'){ openEditor(el); } });

    stage.appendChild(el);
    setSingleSelection(el);
    snapshot();
    return el;
  }

  // Background click → marquee (disabled if drawing)
  stage.addEventListener('pointerdown', (e)=>{
    if(e.target!==stage) return;
    if(drawing) return; // do not start marquee when painting
    const startX=e.clientX, startY=e.clientY;
    marquee.style.left=startX+'px'; marquee.style.top=startY+'px';
    marquee.style.width='0px'; marquee.style.height='0px'; marquee.style.display='block';
    function move(ev){
      const x=Math.min(startX,ev.clientX), y=Math.min(startY,ev.clientY);
      const w=Math.abs(ev.clientX-startX), h=Math.abs(ev.clientY-startY);
      marquee.style.left=x+'px'; marquee.style.top=y+'px'; marquee.style.width=w+'px'; marquee.style.height=h+'px';
    }
    function up(ev){
      marquee.style.display='none';
      const r=marquee.getBoundingClientRect();
      const st=stage.getBoundingClientRect();
      const selRect = { left:(r.left-st.left)/scale, top:(r.top-st.top)/scale, right:(r.right-st.left)/scale, bottom:(r.bottom-st.top)/scale };
      clearSelection();
      [...stage.querySelectorAll('.el')].forEach(el=>{
        const l=parseFloat(el.style.left)||0, t=parseFloat(el.style.top)||0, w=el.clientWidth, h=el.clientHeight;
        const r2 = { left:l, top:t, right:l+w, bottom:t+h };
        // Select if fully contained in marquee (Photoshop-style)
        const contained = r2.left>=selRect.left && r2.right<=selRect.right && r2.top>=selRect.top && r2.bottom<=selRect.bottom;
        if(contained) addToSelection(el);
      });
      window.removeEventListener('pointermove',move);
      window.removeEventListener('pointerup',up);
    }
    window.addEventListener('pointermove',move);
    window.addEventListener('pointerup',up);
  });

  // Element click / selection (shift toggles)
  function onElementPointerDown(e, el){
    if(e.shiftKey){
      if(isSelected(el)) { el.classList.remove('selected'); selection.delete(el); }
      else addToSelection(el);
    } else if(!isSelected(el)){
      setSingleSelection(el);
    }
    if(!e.target.classList.contains('handle')) startDrag(e, el);
  }

  // Drag (single or group)
  let dragState=null;
  function startDrag(e, el){
    const st=stage.getBoundingClientRect();
    const sx = (e.clientX - st.left)/scale;
    const sy = (e.clientY - st.top)/scale;
    const els = selection.size? [...selection] : [el];
    dragState = {
      els,
      bases: els.map(n=>({ el:n, left:parseFloat(n.style.left)||0, top:parseFloat(n.style.top)||0 })),
      dx:0, dy:0, startX:sx, startY:sy
    };
    els.forEach(n=>{ n.style.pointerEvents='none'; n.style.willChange='transform'; });
    window.addEventListener('pointermove', dragging);
    window.addEventListener('pointerup', stopDrag);
  }
  function dragging(e){
    if(!dragState) return;
    const st=stage.getBoundingClientRect();
    const sx = (e.clientX - st.left)/scale;
    const sy = (e.clientY - st.top)/scale;
    const dx = sx - dragState.startX;
    const dy = sy - dragState.startY;
    dragState.dx=dx; dragState.dy=dy;
    dragState.bases.forEach(b=>{ b.el.style.transform = `translate3d(${dx}px, ${dy}px, 0)`; });
    if(selection.size>1) updateGroupBoxTranslate(dx,dy);
  }
  function updateGroupBoxTranslate(dx,dy){
    if(groupBox.style.display==='none') return;
    groupBox.style.transform = `translate3d(${dx}px, ${dy}px,0)`;
  }
  function stopDrag(){
    if(dragState){
      dragState.bases.forEach(b=>{
        b.el.style.left = (b.left + dragState.dx) + 'px';
        b.el.style.top  = (b.top  + dragState.dy) + 'px';
        b.el.style.transform=''; b.el.style.pointerEvents=''; b.el.style.willChange='';
      });
      if(selection.size>1){
        const l=parseFloat(groupBox.style.left)||0, t=parseFloat(groupBox.style.top)||0;
        groupBox.style.left=(l+dragState.dx)+'px';
        groupBox.style.top=(t+dragState.dy)+'px';
        groupBox.style.transform='';
      }
      snapshot(); updateGroupBox();
    }
    dragState=null;
    window.removeEventListener('pointermove', dragging);
    window.removeEventListener('pointerup', stopDrag);
  }

  // Resize (single) — default proportional; Shift = free distort
  let res=null;
  function startResize(e, el, handleEl){ e.stopPropagation();
    if(selection.size>1){ return; } // group via group handle
    const st=stage.getBoundingClientRect();
    res={
      els:[el],
      bases:[{el,left:parseFloat(el.style.left)||0, top:parseFloat(el.style.top)||0, w:el.clientWidth, h:el.clientHeight}],
      startX:(e.clientX-st.left)/scale, startY:(e.clientY-st.top)/scale,
      keepRatio: !e.shiftKey,  // default true; hold Shift to distort
      fromCenter:e.altKey||e.metaKey
    };
    try{ handleEl.setPointerCapture(e.pointerId);}catch{}
    window.addEventListener('pointermove', doResize);
    window.addEventListener('pointerup', stopResize);
  }

  // Group resize via group handle — default proportional; Shift = free distort
  groupHandle.addEventListener('pointerdown', (e)=>{
    if(selection.size<=1) return; e.stopPropagation();
    const st=stage.getBoundingClientRect();
    const gb = {
      left: parseFloat(groupBox.style.left)||0,
      top: parseFloat(groupBox.style.top)||0,
      w: groupBox.clientWidth,
      h: groupBox.clientHeight
    };
    const bases = [...selection].map(el=>({ el, left:parseFloat(el.style.left)||0, top:parseFloat(el.style.top)||0, w:el.clientWidth, h:el.clientHeight }));
    res={
      els:[...selection],
      bases,
      group: gb,
      startX:(e.clientX-st.left)/scale, startY:(e.clientY-st.top)/scale,
      keepRatio: !e.shiftKey,  // default true
      fromCenter:e.altKey||e.metaKey, isGroup:true
    };
    try{ groupHandle.setPointerCapture(e.pointerId);}catch{}
    window.addEventListener('pointermove', doResize);
    window.addEventListener('pointerup', stopResize);
  });

  function doResize(e){
    if(!res) return;
    const st=stage.getBoundingClientRect();
    const cx = (e.clientX - st.left)/scale;
    const cy = (e.clientY - st.top)/scale;
    let dw = (cx-res.startX);
    let dh = (cy-res.startY);

    if(res.isGroup){
      let newW = Math.max(20, res.group.w + dw);
      let newH = Math.max(20, res.group.h + dh);
      if(res.keepRatio){
        const ratio = res.group.w / res.group.h;
        newH = Math.max(20, newW / ratio);
      }
      const sx = newW / res.group.w;
      const sy = newH / res.group.h;
      res.bases.forEach(b=>{
        let nx = res.group.left + (b.left - res.group.left) * sx;
        let ny = res.group.top  + (b.top  - res.group.top ) * sy;
        let nw = b.w * sx;
        let nh = b.h * sy;
        b.el.style.left = nx+'px'; b.el.style.top = ny+'px';
        b.el.style.width = nw+'px'; b.el.style.height = b.el.dataset.type==='text' ? 'auto' : nh+'px';
      });
      groupBox.style.left = res.group.left+'px'; groupBox.style.top = res.group.top+'px';
      groupBox.style.width = newW+'px'; groupBox.style.height = newH+'px';
    }else{
      let base = res.bases[0];
      let newW = Math.max(40, base.w + dw);
      let newH = Math.max(40, base.h + dh);
      if(res.keepRatio){
        const ratio = base.w / base.h;
        newH = Math.max(40, newW / ratio);
      }
      if(res.fromCenter){
        const dx = (newW - base.w)/2;
        const dy = (newH - base.h)/2;
        base.el.style.left = (base.left - dx) + 'px';
        base.el.style.top  = (base.top  - dy) + 'px';
      }
      base.el.style.width = newW+'px';
      base.el.style.height = base.el.dataset.type==='text' ? 'auto' : newH+'px';
    }
  }
  function stopResize(e){
    if(res){ try{ e.target.releasePointerCapture && e.target.releasePointerCapture(e.pointerId);}catch{} snapshot(); }
    res=null; window.removeEventListener('pointermove',doResize); window.removeEventListener('pointerup',stopResize);
  }

  // Editor
  const txt=document.getElementById('txt');
  const fs=document.getElementById('fs');
  const fc=document.getElementById('fc');
  const fontFamily=document.getElementById('fontFamily');
  const stampStyle=document.getElementById('stampStyle');
  function openEditor(el){
    if(el && el.dataset.type==='text'){
      setSingleSelection(el);
      txt.value = el.firstChild.textContent;
      fs.value = parseInt(getComputedStyle(el.firstChild).fontSize);
      fc.value = rgb2hex(getComputedStyle(el.firstChild).color);
      fontFamily.value = getComputedStyle(el.firstChild).fontFamily;
    }
  }
  function rgb2hex(rgb){ const m=rgb.match(/\d+/g); if(!m) return '#000000'; return '#'+m.slice(0,3).map(n=>('0'+parseInt(n).toString(16)).slice(-2)).join(''); }
  function commitEdit(){ if(selection.size===1){ snapshot(); } }
  txt.addEventListener('input', ()=>{ const el=[...selection][0]; if(el && el.dataset.type==='text') el.firstChild.textContent = txt.value; });
  txt.addEventListener('change', commitEdit);
  fs.addEventListener('input', ()=>{ const el=[...selection][0]; if(el && el.dataset.type==='text') el.firstChild.style.fontSize = fs.value+'px'; });
  fs.addEventListener('change', commitEdit);
  fc.addEventListener('input', ()=>{ const el=[...selection][0]; if(el && el.dataset.type==='text') el.firstChild.style.color = fc.value; });
  fc.addEventListener('change', commitEdit);
  fontFamily.addEventListener('change', ()=>{ const el=[...selection][0]; if(el && el.dataset.type==='text') { el.firstChild.style.fontFamily = fontFamily.value; snapshot(); } });
  stampStyle.addEventListener('click', ()=>{ const el=[...selection][0]; if(el && el.dataset.type==='text'){ el.firstChild.classList.toggle('stamp'); el.firstChild.style.color='#fff'; snapshot(); } });

  // Add buttons
  document.getElementById('addText').onclick = ()=> mkEl('text',{x:80,y:80});
  document.getElementById('addLogo').onclick = ()=> mkEl('asset',{src:ASSETS.logo,w:220});
  document.getElementById('addStamp').onclick = ()=> mkEl('asset',{src:ASSETS.stampImg,w:480});
  document.getElementById('addMascot').onclick = ()=> mkEl('asset',{src:ASSETS.mascot,w:380});

  // Uploads
  document.getElementById('uploader').addEventListener('change', e=>{
    const files=[...e.target.files];
    for(const file of files){
      if(uploadCount>=5){ alert('Max 5 uploads reached'); break; }
      const url = URL.createObjectURL(file);
      const el = mkEl('img',{src:url,w:520});
      el.dataset.upload='1'; uploadCount++;
    }
    e.target.value='';
  });

  // Arrange — to extremes
  document.getElementById('front').onclick = ()=>{
    const els = selection.size? [...selection] : [];
    if(!els.length) return;
    const all=[...stage.querySelectorAll('.el')];
    let maxZ = Math.max( ...all.map(n=>parseInt(getComputedStyle(n).zIndex)||1) );
    els.forEach(el=>{ el.style.zIndex = ++maxZ; });
    z = maxZ; snapshot();
  };
  document.getElementById('back').onclick = ()=>{
    const els = selection.size? [...selection] : [];
    if(!els.length) return;
    const all=[...stage.querySelectorAll('.el')];
    const nonSel = all.filter(n=>!selection.has(n));
    nonSel.forEach(n=> n.style.zIndex = (parseInt(getComputedStyle(n).zIndex)||1) + 1 );
    let idx=1;
    els.forEach(el=>{ el.style.zIndex = idx++; });
    z = Math.max(...[...all.map(n=>parseInt(getComputedStyle(n).zIndex)||1)]);
    snapshot();
  };

  document.getElementById('dup').onclick = ()=>{
    if(selection.size===0) return;
    const clones=[];
    selection.forEach(src=>{
      const c=src.cloneNode(true);
      c.style.left=(parseInt(src.style.left||'0')+20)+'px';
      c.style.top=(parseInt(src.style.top||'0')+20)+'px';
      stage.appendChild(c);
      c.querySelector('.handle').addEventListener('pointerdown', (e)=> startResize(e, c, c.querySelector('.handle')));
      c.addEventListener('pointerdown', (e)=> onElementPointerDown(e, c));
      clones.push(c);
    });
    setTimeout(()=>{ clearSelection(); clones.forEach(addToSelection); snapshot(); },0);
  };
  document.getElementById('del').onclick = ()=>{
    if(selection.size){ selection.forEach(el=>{ if(el.dataset.upload==='1') uploadCount=Math.max(0,uploadCount-1); el.remove(); }); clearSelection(); snapshot(); }
  };
  document.getElementById('clear').onclick = ()=>{ [...stage.querySelectorAll('.el')].forEach(n=>n.remove()); uploadCount=0; clearSelection(); dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); snapshot(); };

  // Keyboard
  document.addEventListener('keydown', (e)=>{
    if(!selection.size) return;
    const isInput = ['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName);
    if(isInput) return;
    if(e.key==='Backspace' || e.key==='Delete'){ e.preventDefault(); document.getElementById('del').click(); return; }
    let step = e.shiftKey ? 10 : 1;
    selection.forEach(el=>{
      let l = parseFloat(el.style.left)||0, t=parseFloat(el.style.top)||0;
      if(e.key==='ArrowLeft'){ el.style.left=(l-step)+'px'; }
      else if(e.key==='ArrowRight'){ el.style.left=(l+step)+'px'; }
      else if(e.key==='ArrowUp'){ el.style.top=(t-step)+'px'; }
      else if(e.key==='ArrowDown'){ el.style.top=(t+step)+'px'; }
    });
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){ snapshot(); updateGroupBox(); }
  });

  // Canvas controls
  document.getElementById('applySize').onclick = ()=>{
    const [w,h] = document.getElementById('sizeSel').value.split('x').map(Number);
    setSize(w,h);
    applyZoom(0.5);
    snapshot();
  };
  document.getElementById('bg').oninput = (e)=> { stage.style.background = e.target.value; snapshot(); };

  // Templates
  document.getElementById('blank').onclick = ()=>{ document.getElementById('clear').click(); };
  document.getElementById('tpl').addEventListener('change', e=> loadTpl(e.target.value));
  function ph(w,h,text){ return `https://placehold.co/${w}x${h}?text=${encodeURIComponent(text)}`; }
  function loadTpl(t){
    document.getElementById('clear').click();
    if(t==='beforeAfter'){
      mkEl('text',{x:60,y:40,text:'\"It will never happen\"',size:72});
      mkEl('img',{x:60,y:140,w:700,src:ph(700,600,'BEFORE')});
      mkEl('img',{x:840,y:140,w:700,src:ph(700,600,'AFTER')});
      mkEl('asset',{x:680,y:780,w:260,src:ASSETS.stampImg});
    } else if(t==='reaction'){
      mkEl('text',{x:80,y:80,text:'They said it was dead…',size:96});
      mkEl('asset',{x:1060,y:420,w:380,src:ASSETS.mascot});
      mkEl('asset',{x:80,y:760,w:420,src:ASSETS.stampImg});
    } else if(t==='lieWeek'){
      mkEl('asset',{x:40,y:40,w:160,src:ASSETS.logo});
      mkEl('text',{x:220,y:60,text:'LIE OF THE WEEK',size:96});
      mkEl('img',{x:300,y:220,w:1000,src:ph(1000,520,'Drop Tweet Here')});
      mkEl('asset',{x:590,y:760,w:420,src:ASSETS.stampImg});
    } else if(t==='collage'){
      mkEl('text',{x:60,y:40,text:'Receipts',size:96});
      [[60,160],[840,160],[60,520],[840,520]].forEach((p,i)=> mkEl('img',{x:p[0],y:p[1],w:700,src:ph(700,300,'Receipt '+(i+1))}));
      mkEl('asset',{x:640,y:760,w:320,src:ASSETS.logo});
    } else if(t==='chart'){
      mkEl('text',{x:60,y:60,text:'\"Top is in\" — 2023',size:80});
      mkEl('img',{x:120,y:160,w:1360,src:ph(1360,620,'Chart')});
      mkEl('asset',{x:620,y:760,w:360,src:ASSETS.stampImg});
    } else if(t==='villains'){
      mkEl('text',{x:60,y:40,text:'Top Liars of the Week',size:84});
      [[80,160],[590,160],[1100,160],[80,520],[590,520],[1100,520]].forEach((p,i)=> mkEl('img',{x:p[0],y:p[1],w:420,src:ph(420,420,'#'+(i+1))}));
    } else if(t==='stampOnly'){
      mkEl('asset',{x:550,y:380,w:500,src:ASSETS.stampImg});
    }
  }

  // ===== Paint mode (each stroke becomes an element) =====
  let drawing=false, path=[], bbox=null;
  function setDraw(enabled){
    drawing = enabled;
    drawCanvas.style.pointerEvents = enabled ? 'auto' : 'none';
    document.getElementById('drawToggle').textContent = enabled ? 'Disable Draw' : 'Enable Draw';
  }
  setDraw(false);

  function getRel(e){
    const r = drawCanvas.getBoundingClientRect();
    return { x: (e.clientX - r.left)/scale, y: (e.clientY - r.top)/scale };
  }

  drawCanvas.addEventListener('pointerdown', e=>{
    if(!drawing) return;
    path=[]; bbox=null;
    const p = getRel(e);
    path.push(p);
    dctx.strokeStyle = document.getElementById('brushColor').value;
    dctx.lineWidth = document.getElementById('brushSize').value;
    dctx.lineCap = 'round'; dctx.lineJoin='round';
    dctx.beginPath(); dctx.moveTo(p.x, p.y);
    bbox = {minX:p.x, minY:p.y, maxX:p.x, maxY:p.y, lw:dctx.lineWidth};
    drawCanvas.setPointerCapture(e.pointerId);
  });
  drawCanvas.addEventListener('pointermove', e=>{
    if(!drawing || !path.length) return;
    const p = getRel(e);
    path.push(p);
    dctx.lineTo(p.x, p.y); dctx.stroke();
    bbox.minX = Math.min(bbox.minX, p.x);
    bbox.minY = Math.min(bbox.minY, p.y);
    bbox.maxX = Math.max(bbox.maxX, p.x);
    bbox.maxY = Math.max(bbox.maxY, p.y);
  });
  drawCanvas.addEventListener('pointerup', e=>{
    if(!drawing || !path.length) return;
    dctx.closePath(); drawCanvas.releasePointerCapture(e.pointerId);
    // Create an image element from the stroke
    const pad = bbox.lw/2 + 2;
    const x = Math.max(0, Math.floor(bbox.minX - pad));
    const y = Math.max(0, Math.floor(bbox.minY - pad));
    const w = Math.ceil((bbox.maxX + pad) - x);
    const h = Math.ceil((bbox.maxY + pad) - y);
    // offscreen canvas
    const off = document.createElement('canvas'); off.width=w; off.height=h;
    const octx = off.getContext('2d');
    octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality='high';
    // draw path relative
    octx.strokeStyle = document.getElementById('brushColor').value;
    octx.lineWidth = document.getElementById('brushSize').value;
    octx.lineCap='round'; octx.lineJoin='round';
    octx.beginPath();
    for(let i=0;i<path.length;i++){
      const px = path[i].x - x;
      const py = path[i].y - y;
      if(i===0) octx.moveTo(px,py); else octx.lineTo(px,py);
    }
    octx.stroke(); octx.closePath();
    const url = off.toDataURL("image/png");
    // clear the overlay stroke
    dctx.clearRect(x, y, w, h);
    // insert as movable element
    mkEl('img',{x,y,w,src:url});
    snapshot();
    path=[]; bbox=null;
  });

  document.getElementById('drawToggle').onclick = ()=> setDraw(!drawing);
  document.getElementById('clearDraw').onclick = ()=> { dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); snapshot(); };

  // Export (contain fit)
  document.getElementById('export').onclick = async ()=>{
    const w = drawCanvas.width, h = drawCanvas.height;
    const out = document.createElement('canvas'); out.width=w; out.height=h; const ctx=out.getContext('2d');
    ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
    ctx.fillStyle = getComputedStyle(stage).backgroundColor; ctx.fillRect(0,0,w,h);
    const els=[...stage.querySelectorAll('.el')].sort((a,b)=> (parseInt(getComputedStyle(a).zIndex)||0)-(parseInt(getComputedStyle(b).zIndex)||0));
    for(const el of els){
      const x=parseFloat(el.style.left)||0, y=parseFloat(el.style.top)||0, width=el.clientWidth, height=el.clientHeight;
      if(el.dataset.type==='img' || el.dataset.type==='asset'){
        const img=el.querySelector('img');
        await drawContained(ctx, img, x, y, width, height);
      } else if(el.dataset.type==='text'){
        const box=el.firstChild; const st=getComputedStyle(box); const isStamp=box.classList.contains('stamp');
        if(isStamp){
          ctx.fillStyle=getComputedStyle(stage).getPropertyValue('--brand')||'#ca3028';
          roundRect(ctx,x,y,box.offsetWidth+24,box.offsetHeight+12,8); ctx.fill();
          ctx.fillStyle='#fff'; ctx.font=`900 ${parseInt(st.fontSize)}px ${st.fontFamily}`; ctx.textBaseline='top';
          ctx.fillText(box.textContent, x+12, y+6);
        } else {
          ctx.fillStyle=st.color; ctx.font=`900 ${parseInt(st.fontSize)}px ${st.fontFamily}`; ctx.textBaseline='top';
          wrapText(ctx, box.textContent, x, y, box.offsetWidth, parseInt(st.fontSize)*1.05);
        }
      }
    }
    const url = out.toDataURL("image/png");
    const a=document.createElement('a'); a.href=url; a.download='they_lied_meme.png'; a.click();
  };

  function drawContained(ctx, img, x, y, w, h){
    return new Promise(res=>{
      function go(){
        try{
          const iw = img.naturalWidth || img.width;
          const ih = img.naturalHeight || img.height;
          if(iw && ih){
            const s = Math.min(w/iw, h/ih);
            const dw = iw*s, dh = ih*s;
            const dx = x + (w-dw)/2;
            const dy = y + (h-dh)/2;
            ctx.drawImage(img, dx, dy, dw, dh);
          }
        }catch{}
        res();
      }
      if(img.complete) go(); else { img.onload=go; img.onerror=res; }
    });
  }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function wrapText(ctx, text, x, y, maxWidth, lh){ const words=text.split(' '); let line=''; for(let n=0;n<words.length;n++){ const test=line+words[n]+' '; if(ctx.measureText(test).width>maxWidth && n>0){ ctx.fillText(line,x,y); line=words[n]+' '; y+=lh; } else { line=test; } } ctx.fillText(line,x,y); }

  snapshot();
})();
</script>
</body>
</html>
